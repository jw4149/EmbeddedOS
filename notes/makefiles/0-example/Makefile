# makefile 0.
#
# a very simple-minded Makefile that hardcodes all dependencies
# and:
#  1. produces an executable file <main> by compiling
#     C files <a.c>, <b.c>, <c.c>, <main.c> and a header 
#     file <header.h>
#  2. checks that the <main> is the same as a reference
#     <main.ref>
#
all: main test

# hardcode that <main> depends on <a.c> <b.c> <c.c> <main.c> and
# <header.h>
#
# what this means mechanically: if the modification time of any
# of these files changes so it's more recent than the modification
# time of <main> (or if <main> doesn't exist) the rule will execute.
#
# easy test:
#  % make clean  # removes <main>
#  % make        # produces <main>
#  % make        # should not re-compile <main>
#  % touch header.h
#  % make        # will produce <main>
#
# note: we don't ever compile these files to a .o we just
# compile them as a big single command using gcc.  this is 
# the simplest, easiest way to do this.  for small projects
# there's no reason to mess with incremental compilation.
main: a.c b.c c.c main.c header.h
	# main: rule
	$(CC) a.c b.c c.c main.c -o main

# make sure <main> produces the same result as reference
# output in <main.ref>:
#  1. run <main> and put the output in file <out>;
#  2. check if they differ using <diff>
#
# This will rerun each time you run `make`
test: main
	# test: rule
	./main > out
	diff out main.ref
	@echo "makefile: program 'main' passed test"
	@rm -f out

# cleanup remove outputs and temporary files
clean:
	rm -f main out *~ *.bak

# tell `make` that these rules don't produce a file
# of the same name (they are phoney -- fake --- target
# names)
.PHONY: all test clean 
