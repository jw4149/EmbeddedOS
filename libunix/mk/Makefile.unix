# USAGE:
#  user must define: 
#   - PROGS : the names of the driver program files
#  can define:
#   - <COMMON_SRC>: shared source across all programs.
#   - <LIBS>: additional libraries.
MAKEFLAGS += --no-print-directory

ifndef PROGS
    $(error "<PROGS> is not defined!")
endif

ifdef RUN
ifneq ($(RUN),0)
    RUN_PROGS = run
endif
endif


BUILD_DIR ?= ./objs

ifdef CS140E_USE_STAFF
    LIBUNIX_PATH := $(CS140E_STAFF_2024_PATH)/libunix
else
    LIBUNIX_PATH := $(CS140E_2024_PATH)/libunix
endif
MK_CHK = $(LIBUNIX_PATH)/mk/Makefile.check-v3

LIBS += $(LIBUNIX_PATH)/libunix.a


ifeq ($(RUN),1)
TEST_RUN   := $(patsubst %.c, %.run, $(PROG_SRC))
endif

progs := $(PROGS:.c=)
progs_run    := $(PROGS:.c=.run)

common_objs := $(COMMON_SRC:.c=.o)
prog_objs := $(PROGS:.c=.o)
built_objs := $(common_objs) $(prog_objs)
built_dirs := $(sort $(dir $(built_objs)))
VPATH := $(built_dirs)    # tell make where to look.

common_objs := $(foreach o, $(common_objs), $(BUILD_DIR)/$(notdir $(o)))
prog_objs   := $(foreach o, $(prog_objs), $(BUILD_DIR)/$(notdir $(o)))
built_objs  := $(common_objs) $(prog_objs)

# every built object should have a .d file in the build dir.
built_deps := $(built_objs:.o=.d)

# all files to tag: we manually list out the .h's
headers += $(foreach d, $(built_dirs), $(wildcard $d*.h))
all_tags := $(COMMON_SRC) $(PROGS) $(headers)

LU = $(LIBUNIX_PATH)/libunix.a

# update the compilation include flags to look in all directories.
# this will not work great if same .h name is used in different
# directories.
INCFLAGS += $(foreach d, $(built_dirs), -I$(d)) -I$(LIBUNIX_PATH)
DEPFLAGS =  -MT $@ -MMD -MP -MF $(BUILD_DIR)/$*.d

OPT_LEVEL ?= -Og
CC=gcc

CFLAGS += $(OPT_LEVEL) -Wall -g -std=gnu99  -Werror -Wno-unused-function -Wno-unused-variable -DRPI_UNIX

# added the include path for libpi-fake
DEPS += $(MAKEFILE_LIST)

all:: libs $(LIBS) $(progs) $(RUN_PROGS) # $(TEST_RUN) # $(OBJS)  

print:
	@echo "libs=$(LIBS)"
	@echo "LU=$(LU)"

libs:: FORCE
	@make -C $(LIBUNIX_PATH)

$(LU): FORCE
	make -C $(LIBUNIX_PATH)
FORCE:
.PHONY: FORCE

%.run: %
	@echo "------------------about to run <$^>-----------------------";
	./$^

# this won't run without FORCE?
$(BUILD_DIR): FORCE
	@mkdir -p $(BUILD_DIR)

.PHONY: FORCE
FORCE:

$(progs):%: $(BUILD_DIR)/%.o $(BUILD_DIR)/%.d $(common_objs) $(DEPS) $(LU) $(LIBS)
	$(CC) $< $(common_objs) -o $@ $(LIBS) $(LU)

%.o:%.c
%.d:%.c
# have .d as an explicit dependency so catch some
# mistakes.
$(built_objs):
$(built_deps):
$(BUILD_DIR)/%.o: %.c  $(BUILD_DIR)/%.d $(DEPS) | $(BUILD_DIR)
	$(CC) $(CFLAGS) $(INCFLAGS) $(DEPFLAGS) -c $< -o $@

# tell make not to panic if no .d exists: will get
# generated by the end.
# %.d: ;

%.run: %
	./$<
run: $(progs_run)

ifneq ($(CAN_EMIT), 0)
emit: libs $(DEPS) $(progs) FORCE
	make -e -f $(MK_CHK) emit "TESTS=$(progs)"
else
emit: 
	$(error "not allowed to emit")
endif

check: libs $(DEPS) $(progs)
	@make -f $(MK_CHK) check "TESTS=$(progs)" "PROLOGUE=$(PROLOGUE)"

ifneq ($(MAKECMDGOALS),clean)
ifneq ($(MAKECMDGOALS),cleanall)
-include $(built_deps)  # include dep files
endif
endif

# Rule Definitions
# define library_rule
# $(1):
#	@echo "Building $(1)";
#	@make -C $(dir $(1)) $(notdir $(1))
#endef

# Usage of Rule Definitions
#$(foreach lib, $(LIBS), $(eval $(call library_rule,$(lib))))

tags:
	ctags $(all_tags)

clean :
	rm -fr $(BUILD_DIR) *~ Makefile.bak $(built_objs)  $(progs) tags
	@make -f $(MK_CHK) clean "TESTS=$(progs)"

.PHONY: clean tags run check   emit # $(LIBS)
