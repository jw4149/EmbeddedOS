# common makefile template we use to generate libraries on unix.

# where we put objects.
BUILD_DIR ?= ./objs

ifndef LIBNAME
$(error LIBNAME is not set in the calling Makefile)
endif

ifndef LIB_SRC
$(error LIB_SRC is not set in the calling Makefile)
endif

# current makefile
DEPS := $(firstword $(MAKEFILE_LIST))

# should probably let them override optimizations.
CFLAGS += $(INC) -Og -Wall -Wno-unused-function -Wno-unused-variable -MMD -MP -DRPI_UNIX

##################################################################
# compute all the directories we get code from.
lib_dirs := $(sort $(dir $(LIB_SRC))) 

# tell make where to search for prereqs.
VPATH := $(lib_dirs) $(BUILD_DIR)

# strip all the directories and relocate to BUILD_DIR
lib_reloc := $(foreach o, $(LIB_SRC), $(notdir $o))
lib_reloc := $(foreach o, $(lib_reloc), $(BUILD_DIR)/$(o))
lib_objs := $(lib_reloc:.c=.o)

all_deps    := $(lib_reloc:.c=.d)

all:: $(BUILD_DIR) $(LIBNAME) 

$(BUILD_DIR): 
	@mkdir -p $(BUILD_DIR)

$(LIBNAME): $(lib_objs) $(THIS_MAKEFILE)
	ar cr $(LIBNAME) $(lib_objs)

# have .d as an explicit dependency so catch some
# mistakes.
$(BUILD_DIR)/%.o: %.c  $(BUILD_DIR)/%.d $(DEPS)
	$(CC) $(CFLAGS) -c $< -o $@

# tell make not to panic if no .d exists: will get
# generated by the end.
$(BUILD_DIR)/%.d: ;

# all the dependency files computed
ifneq ($(MAKECMDGOALS),clean)
ifneq ($(MAKECMDGOALS),cleanall)
-include $(all_deps)  # include dep files
endif
endif

clean::
	rm -rf *~  *.bak  $(LIBNAME) includes.mk
	rm -rf $(BUILD_DIR)

.PHONY: all clean $(BUILD_DIR)
.PRECIOUS:  $(BUILD_DIR)/%.o 
.PRECIOUS:  $(BUILD_DIR)/%.d 
